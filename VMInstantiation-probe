#! /usr/bin/perl -w
# nagios: -epn 
#
# Probe for checking the successful instantiation of a virtual machine
# Copyright (c) 2011 Piotr Kasprzak, Ali Jehangiri
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Installation:
#
# perl -MCPAN -e shell
# cpan> install Nagios::Plugin
# cpan> install Log::Log4perl

#
# Changes and Modifications
# =========================
# 07-Dec-2011 - 0.1: Created;

use strict;
use warnings;
use Nagios::Plugin;
use Log::Log4perl;
use LWP::UserAgent;

use Data::Dumper;

# Standard variables used in Nagios::Plugin constructor
my $PROGNAME	= 'VMInstantiation-probe';
my $VERSION		= '0.2';
my $DESCRIPTION	= 'Probe for checking the successful instantiation of a virtual machine';
my $EXTRA_DESC	= '';
my $SHORTNAME	= 'VM INSTANTIATION';

my $LICENSE		= 'This nagios plugin is free software, and comes with ABSOLUTELY NO WARRANTY.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Copyright 2011 Piotr Kasprzak, Ali Jehangiri';

# ---------------------------------------------------------------------------------------------------------------------
# Initialize logger

my $log4j_conf = q(

    log4perl.category.FedCloud.Nagios   = DEBUG, Screen

#  log4perl.appender.Logfile          = Log::Log4perl::Appender::File
#  log4perl.appender.Logfile.filename = test.log
#  log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::PatternLayout
#  log4perl.appender.Logfile.layout.ConversionPattern = [%r] %F %L %m%n

    log4perl.appender.Screen            = Log::Log4perl::Appender::Screen
    log4perl.appender.Screen.stderr     = 0
    log4perl.appender.Screen.layout     = Log::Log4perl::Layout::PatternLayout
    log4perl.appender.Screen.layout.ConversionPattern = [%d %F:%M:%L] %m%n
);

Log::Log4perl::init(\$log4j_conf);

our $log = Log::Log4perl::get_logger("FedCloud::Nagios");

# ---------------------------------------------------------------------------------------------------------------------
# Execute shell command

sub exec_cmd {

    my $c = shift; my ($state, $result);

    $result = qx/$c/;
    if ($? == -1) {
        $state = CRITICAL;
    } else {
        $state = OK;
    };

    return ($state, $result);
}

# ---------------------------------------------------------------------------------------------------------------------
# Perl doesn't seem to have trim...

sub trim {

    my $string = shift;

    $string =~ s/^\s+//;
    $string =~ s/\s+$//;

    return $string;
}

# ---------------------------------------------------------------------------------------------------------------------
# Remove quotes froms string (brutal version)

sub remove_quotes {

    my $string = shift;

    $string =~ s/"//g;
    $string =~ s/'//g;

    return $string;
}

# ---------------------------------------------------------------------------------------------------------------------
# Construct a HTTP::Request object to be used for communication with the OCCI-service

sub construct_request {

    our $plugin;

    my $method 		= shift;
    my $endpoint	= shift;
	
    my $request;

    $request = HTTP::Request->new($method	=> $endpoint);
    $request->header('Accept'				=> 'text/occi');
	
    # Support basic auth
    unless ($plugin->opts->user eq '' or $plugin->opts->password eq '') {
        $request->authorization_basic($plugin->opts->user, $plugin->opts->password);
    }

    return $request;
}

# ---------------------------------------------------------------------------------------------------------------------
# Parse OCCI attributes from X-OCCI-Attribute header and return them as a nice name -> value hash

sub parse_attributes {

    my $attribute_header = shift;
    my @attributes = split(/,/, $attribute_header);
    my %attributes_hash;

    foreach (@attributes) {
	    if (trim($_) =~ m/(.*)=(.*)/) {
            $attributes_hash{remove_quotes($1)} = remove_quotes($2);
        }
    }
    return %attributes_hash;
}

# ---------------------------------------------------------------------------------------------------------------------
# Search for the location / OCCI-id of a resource given it's type and name

sub find_resource_location {

    our $http_agent;
    our %type_locations;
    our $plugin;
    our $log;

    my $class   = shift;
    my $type    = shift;
    my $name    = shift;
    my ($request, $response);
	
    my $type_location = $type_locations{$class}{$type};
	
    $log->info("Searching for resource '$name' of type '$type' of class '$class' at location '$type_location'...");
	
    if (not defined $type_location) { $plugin->nagios_exit(CRITICAL, "Could not find location for '$name' resource type!"); }
	
    $request	= construct_request("GET", $type_location);
    $response	= $http_agent->request($request);

    if ($response->is_success) {

        my @locations = split(/,/, $response->header("X-OCCI-Location"));
        foreach (@locations) {
            # Search for target resource by evaluating its name
            my $location = trim($_);
            $request = construct_request("GET", $location);
            $response = $http_agent->request($request);
            if ($response->is_success) {
                my %attributes_hash = parse_attributes($response->header("X-OCCI-Attribute"));
                if ($attributes_hash{"occi.core.title"} =~ m/$name/i) {
                    my ($occi_id, $occi_location) = ($attributes_hash{"occi.core.id"}, $location);
                    $log->info("Found at: $occi_location");
                    return ($occi_id, $occi_location);
                }
            } else {
                $plugin->nagios_exit(CRITICAL, "HTTP error while searching for resource '$name': " . $response->status_line); 
            }
        }		
    }
    $plugin->nagios_exit(CRITICAL, "Resource '$name' could not be found!");
}

# ---------------------------------------------------------------------------------------------------------------------
# Deleted instantiated OCCI compute resource if necessary to clean up

sub delete_compute {
	
    our $compute_location;
    our $http_agent;
    our $plugin;
    our $log;
	
    if (defined $compute_location) {
        $log->info("Destroying compute resource at $compute_location...");
        my $request = construct_request("DELETE", $compute_location);
        my $response = $http_agent->request($request);
        if (not $response->is_success) {
            $plugin->nagios_exit(CRITICAL, "Compute resource at location '$compute_location' could not be deleted: " . $response->status_line);
        }
    } else {
        # Nothing to do, no compute resource location defined
    } 
}

# ---------------------------------------------------------------------------------------------------------------------
# Render attributes hash to header string

sub render_attributes {

    our $log;

    my $attributes = shift;
    my $header = "";

    while (my ($attribute_name, $attribute_value) = each(%$attributes)) {
        $header = qq(${header}${attribute_name}="${attribute_value}",);
    }	
	
    $log->info("OCCI-Attributes: $header");
	
    return substr($header, 0, length($header) - 1);
}

# ---------------------------------------------------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------------------------------------------------

$log->info("Started probe '$PROGNAME'...");

# Fix for too long headers ("500 Line too long (limit is 4096)")
push(@LWP::Protocol::http::EXTRA_SOCK_OPTS, MaxLineLength => 16*1024);

# Create Nagios::Plugin instance
our $plugin = Nagios::Plugin->new ( usage 	    => "Usage: %s <-H <hostname> -p <port>>|<-f <file>>",
                                    shortname	=> $SHORTNAME,
                                    version	    => $VERSION,
                                    blurb		=> $DESCRIPTION,
                                    extra		=> $EXTRA_DESC,
                                    license	    => $LICENSE,
                                    plugin 	    => $PROGNAME);

# Compute resource default attributes
my %vm_attributes = (
    'occi.core.title'		    => "FedCloud Nagios Probe VM",
    'occi.core.summary'		    => "",
    'occi.compute.architecture'	=> "x64",
    'occi.compute.cores'		=> 1,
    'occi.compute.memory'		=> 1	
);

my $attribute_header = render_attributes(\%vm_attributes);

# Define additional arguments

$plugin->add_arg(
    spec        => 'hostname|H=s',
    help        => "H|hostname\n   Name or IP address of host to check.\n   (default: localhost)",
    required    => 0,
    default     => 'localhost'
);

$plugin->add_arg(
    spec        => 'port|p=i',
    help        => "p|port\n   Port of the OCCI service.\n   (default: 3000)",
    required    => 0,
    default     => 3000
);

$plugin->add_arg(
    spec        => 'user|u=s',
    help        => "u|user\n   OCCI-service username.\n   (default: none)",
    required    => 0,
    default	    => ''
);

$plugin->add_arg(
    spec        => 'password|P=s',
    help        => "P|password\n   OCCI-service password.\n   (default: none)",
    required    => 0,
    default     => ''
);

$plugin->add_arg(
    spec        => 'network|n=s',
    help        => "n|network\n   Name of the network to use for compute resource instantiation.\n   (default: GWDG-Cloud)",
    required    => 0,
    default     => 'GWDG-Cloud'
);

$plugin->add_arg(
    spec        => 'image|i=s',
    help	    => "i|image\n   Name of the image to use for compute resource instantiation.\n   (default: Ubuntu 11.10 Server)",
    required    => 0,
    default     => 'Ubuntu 11.10 Server'
);

$plugin->add_arg(
    spec        => 'attributes|a=s',
    help        => "a|attributes\n   Comma separated list of OCCI attributes for the instantiation of the compute resource. Provided attribute values override defaults.\n   (defaults: $attribute_header)",
    required    => 0,
    default     => $attribute_header
);

$plugin->add_arg(
    spec        => 'imagerepo|r=s',
    help        => "r|imagerepo\n   Type of image repository to use.\n   (default: one)",
    required    => 0,
    default     => 'one'
);

$plugin->add_arg(
    spec        => 'marketplace|m=s',
    help        => "m|\n   Marketplace endpoint.\n   (default: http://marketplace.stratuslab.eu)",
    required    => 0,
    default     => 'http://marketplace.stratuslab.eu'
);

$plugin->add_arg(
    spec        => 'cert|c=s',
    help        => "c|cert\n   Location of certificate for X509 authentication.\n   (default: /etc/nagios/hostcert.pem)",
    required    => 0,
    default     => '/etc/nagios/hostcert.pem'
);

$plugin->add_arg(
    spec        => 'key|k=s',
    help        => "k|key\n   Location of certificate for X509 authentication..\n   (default: /etc/nagios/hostkey.pem)",
    required    => 0,
    default     => '/etc/nagios/hostkey.pem'
);




$plugin->getopts;

# Signal handler - TERM

local $SIG{ALRM} = sub {
    local $SIG{TERM} = 'IGNORE';
    kill TERM => -$$;
    delete_compute();
    $plugin->nagios_exit(CRITICAL, "Compute resource could not be provisioned in the allocated time (" . $plugin->opts->timeout . "s)");
};

local $SIG{TERM} = sub {
    local $SIG{TERM} = 'IGNORE';
    kill TERM => -$$;
    delete_compute();
    $plugin->nagios_die("Plugin received TERM signal.");
};

alarm($plugin->opts->timeout);

# set environment for X509 authentication if username and pass are not set
#local %ENV = %ENV;

 
if ($plugin->opts->user eq '' or $plugin->opts->password eq '') {

#    $ENV{HTTPS_DEBUG} = 1;
    $ENV{HTTPS_CA_DIR} 	  = '/etc/grid-security/certificates';

    $ENV{HTTPS_KEY_FILE}  = $plugin->opts->key  if ( -f $plugin->opts->key );
    $ENV{HTTPS_CERT_FILE} = $plugin->opts->cert if ( -f $plugin->opts->cert );

}

my ($state, $result, $curl);
my ($request, $response);

my $occi_endpoint = $plugin->opts->hostname . ":" . $plugin->opts->port;

$log->info("Using OCCI service at: $occi_endpoint");

# Create HTTP agent
our $http_agent = undef;

if ($plugin->opts->user eq '' or $plugin->opts->password eq '') {

    $http_agent = LWP::UserAgent->new(
        ssl_opts   => {
#        	verify_hostname => 1,
            SSL_cert_file   => '/root/cert.pem',
            SSL_key_file    => '/root/key.pem',
        },
    );
} else {
    $http_agent = LWP::UserAgent->new;
}

$request	= construct_request("GET", $occi_endpoint . "/-/");
$response	= $http_agent->request($request);

# Build category -> location hash
$log->info("Creating category -> location hash...");

our %type_locations = ( mixins  => {},
                        classes => {});
if ($response->is_success) {

    $log->info("Response: " . $response->header("Category"));
    my @categories = split(/,/, $response->header("Category"));

    foreach (@categories) {

        $log->info("   Processing category string: $_");

        my @desc_elements = split(/;/, $_);
        my $term        = $desc_elements[0];
        my $location    = undef;
        my $class       = undef;

        foreach (@desc_elements) {

            $log->info("      Processing element: $_");

            # Check for location attribute
            if ($_ =~ m/location=(.*)/) {
                $location = remove_quotes($1);
                $log->info("         => got location: $location");
                if ($location !~ m/^http[s]?:\/\//i) {
                    # Relative links provided, need to extend them
                    $location = $occi_endpoint . trim($location);
                    $log->info("         => extended location: $location");
                }
		    }

            # Check for class attribute
            if ($_ =~ m/class=(.*)/) {
                $class = remove_quotes($1);
                $log->info("         => got class: $class");
            }
		}

        # Add entry to type_locations hash
        if (defined($location)) {
            $type_locations{$class}{$term} = $location;
        }
	};
}
else {
    $plugin->nagios_exit(CRITICAL, "HTTP request failed: " . $response->status_line);
}

# Find the needed resources (storage and network)
my ($storage_id, $storage_location);

if ( $plugin->opts->imagerepo eq "one" ) {
    ($storage_id, $storage_location) = find_resource_location("kind", "storage", $plugin->opts->image);
    $storage_location = substr($storage_location, length($occi_endpoint));
} elsif ( $plugin->opts->imagerepo eq "stratuslab" ) {
    $storage_location = $plugin->opts->marketplace . "/metadata/" . $plugin->opts->image;
} else {
    $plugin->nagios_exit(CRITICAL, "Unknown image repository: " . $plugin->opts->imagerepo);
}

my ($network_id, $network_location) = find_resource_location("kind", "network", $plugin->opts->network);

# Make locations relative
$network_location = substr($network_location, length($occi_endpoint));

# Create virtual machine with links to selected network and storage resources

# Parse provided attributes and merge them with the defaults
my %provided_vm_attributes = parse_attributes($plugin->opts->attributes);
%vm_attributes = (%vm_attributes, %provided_vm_attributes);
$attribute_header = render_attributes(\%vm_attributes);

# Stuart changes:
#my $link_header =	"<$network_location>" . q|;rel="http://schemas.ogf.org/occi/infrastructure#network";category="http://schemas.ogf.org/occi/core#link";,| .
#					"<$storage_location>" . q|;rel="http://schemas.ogf.org/occi/infrastructure#storage";category="http://schemas.ogf.org/occi/core#link";|;

my $link_header = "<$network_location>" . q|;rel="http://schemas.ogf.org/occi/infrastructure#network";category="http://schemas.ogf.org/occi/core#link";,| . "<$storage_location>";

if ( $plugin->opts->imagerepo eq "stratuslab" ){
    $link_header = $link_header . q|;rel="http://schemas.ogf.org/occi/core#link";category="http://schemas.ogf.org/occi/infrastructure#storagelink";|;
} else {
    $link_header = $link_header . q|;rel="http://schemas.ogf.org/occi/infrastructure#storage";category="http://schemas.ogf.org/occi/core#link";|;
}

my $category_header = q|compute; scheme="http://schemas.ogf.org/occi/infrastructure#";class="kind";|;

$request = construct_request("POST", $occi_endpoint . "/compute/");
$request->header('Category'			=> $category_header);
$request->header('X-OCCI-Attribute'	=> $attribute_header);
$request->header('Link'				=> $link_header);

$log->info("Compute resource instantiation request: " . $request->as_string);

$response = $http_agent->request($request);

print $response->headers_as_string;

if (not $response->is_success) {
    $plugin->nagios_exit(CRITICAL, "Could not instantiate virtual machine: " . $response->status_line); 
}

# Wait till compute resource is online
our $compute_location = undef;

defined($response->header("Location"))          && ($compute_location = $response->header("Location"));
defined($response->header("X-OCCI-Location"))   && ($compute_location = $response->header("X-OCCI-Location"));

if (not ($response->is_success && defined($compute_location))) {
    $log->info("Could not determine location of instantiated VM!");
    $log->info("Response: " . Dumper(\$response));
    $plugin->nagios_exit(CRITICAL, "Could not instantiate virtual machine: no location!");
} 

$log->info("Location of compute instance: $compute_location");

$request = construct_request("GET", $compute_location);

# Poll
while (1) {
    $response = $http_agent->request($request);
#    print Dumper(\$response);
    if ($response->is_success) {
        my %attributes_hash = parse_attributes($response->header("X-OCCI-Attribute"));
        $log->info("Waiting for state 'active', current state: " . $attributes_hash{"occi.compute.state"});
        if ($attributes_hash{"occi.compute.state"} eq "active") {
            last;
        }
    }
    sleep(1);
}

# Delete compute resource
delete_compute();

$plugin->nagios_exit(OK, "Compute resource was successfully instantiated and deleted.");

